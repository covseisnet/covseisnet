

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="english" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="english" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>covseisnet.arraystream &mdash; covseisnet 0.3.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> covseisnet
          

          
            
            <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#manual-installation">Manual installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../guide.html">User's Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../guide.html#roadmap">Roadmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide.html#dealing-with-array-seismic-data">Dealing with array seismic data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide.html#network-covariance-matrix-analysis">Network covariance matrix analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html">Gallery</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../auto_examples/plot_example_2.html">Single-station covariance matrix spectral width</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../auto_examples/plot_example_1.html">Single-station covariance matrix</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Package structure</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#module-covseisnet.covariancematrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">covseisnet.covariancematrix</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#module-covseisnet.arraystream"><code class="xref py py-mod docutils literal notranslate"><span class="pre">covseisnet.arraystream</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../license.html#preamble">Preamble</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../license.html#how-to-apply-these-terms-to-your-new-programs">How to Apply These Terms to Your New Programs</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">covseisnet</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>covseisnet.arraystream</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for covseisnet.arraystream</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Read and pre-process seismic data.</span>

<span class="sd">Todo</span>
<span class="sd">----</span>
<span class="sd">- Implement the new :meth:`~covseisnet.data.ArrayStream.synchronize` method.</span>
<span class="sd">- Implement a :meth:`covseisnet.data.ArrayStream.check_synchronicity` method.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">obspy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>


<div class="viewcode-block" id="ArrayStream"><a class="viewcode-back" href="../../api.html#covseisnet.arraystream.ArrayStream">[docs]</a><span class="k">class</span> <span class="nc">ArrayStream</span><span class="p">(</span><span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">Stream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;List-like object of multiple ObsPy trace objects (synchroneous).</span>

<span class="sd">    This class is a subclass of the :class:`obspy.core.stream.Stream` class,</span>
<span class="sd">    with additional methods pre-processing methods. The main idea is to</span>
<span class="sd">    gather traces with an exact same amount of samples per traces in order</span>
<span class="sd">    to perform array-procesing methods onto it. The synchronization of the</span>
<span class="sd">    different traces objects is not automatic. There are two options for</span>
<span class="sd">    synchronizing the stream:</span>

<span class="sd">    (1) use the :meth:`~covseisnet.data.ArrayStream.synchronize`</span>

<span class="sd">        &gt;&gt;&gt; import covseisnet as cn</span>
<span class="sd">        &gt;&gt;&gt; stream = cn.data.read()</span>
<span class="sd">        &gt;&gt;&gt; stream.synchronize()</span>

<span class="sd">    (2) perform a manual synchronization before turning the stream</span>
<span class="sd">        into an :class:`covseisnet.ArrayStream` object with</span>

<span class="sd">        &gt;&gt;&gt; import covseisnet as cn</span>
<span class="sd">        &gt;&gt;&gt; stream = obspy.read()</span>
<span class="sd">        &gt;&gt;&gt; # manually synchronize</span>
<span class="sd">        &gt;&gt;&gt; stream = cn.data.ArrayStream(stream)</span>

<span class="sd">    Note</span>
<span class="sd">    -----</span>
<span class="sd">    All the original methods of :class:`obspy.core.stream.Stream` objects</span>
<span class="sd">    remain available in :class:`~covseisnet.data.ArrayStream` objects. For more</span>
<span class="sd">    information, please visit the ObsPy documentation at</span>
<span class="sd">    https://examples.obspy.org.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Subclassing.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ArrayStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="ArrayStream.cut"><a class="viewcode-back" href="../../api.html#covseisnet.arraystream.ArrayStream.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Cut (trim) seismic traces between given start and end times.</span>

<span class="sd">        This function is a wrapper to the :meth:`obspy.core.stream.Stream.trim`</span>
<span class="sd">        method, but works directly with datetimes in :class:`str` format.</span>
<span class="sd">        The function uses the native ObsPy</span>
<span class="sd">        :class:`~obspy.core.utcdatetime.UTCDateTime` class in order</span>
<span class="sd">        to convert the datetimes from :class:`str` into</span>
<span class="sd">        :class:`obspy.core.utcdatetime.UTCDateTime` format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        starttime : str</span>
<span class="sd">            The starting date time. Can be in any format that the</span>
<span class="sd">            :class:`~obspy.core.utcdatetime.UTCDateTime` can parse.</span>
<span class="sd">            For instance ``starttime=&quot;2010-01-01 10:34&quot;``.</span>

<span class="sd">        endtime : str</span>
<span class="sd">            The ending date time, with the same constrain that the</span>
<span class="sd">            ``starttime`` parameter.</span>

<span class="sd">        Keyword arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        **kwargs: dict, optional</span>
<span class="sd">            Additional keyword arguments are passed to the</span>
<span class="sd">            :meth:`obspy.core.stream.Stream.trim` method.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; stream = cn.data.read()</span>
<span class="sd">        &gt;&gt;&gt; stream.cut(&#39;2009-08-24 00:20:05&#39;, &#39;2009-08-24 00:20:12&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(stream)</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:05.000000Z... | 100.0 Hz, 701 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:05.000000Z... | 100.0 Hz, 701 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:05.000000Z... | 100.0 Hz, 701 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">starttime</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">endtime</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ArrayStream.preprocess"><a class="viewcode-back" href="../../api.html#covseisnet.arraystream.ArrayStream.preprocess">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;frequency&quot;</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;onebit&quot;</span><span class="p">,</span>
        <span class="n">window_duration_sec</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
        <span class="n">smooth_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">smooth_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-10</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Preprocess seismic traces all at once.</span>

<span class="sd">        This method provides tools for preprocessing the input data in the time</span>
<span class="sd">        or frequency domain. The preprocessing domain is managed by the</span>
<span class="sd">        keyword argument `domain`, and the following rules apply:</span>

<span class="sd">        **Frequency-domain pre-processing**</span>

<span class="sd">        Considering :math:`x_i(t)` being the input seismic trace at station</span>
<span class="sd">        :math:`i`, the normalized trace :math:`x^N_i(t)` is obtained</span>
<span class="sd">        from the inverse short-time Fourier transform of the modified</span>
<span class="sd">        spectrogram :math:`\tilde{x}_i(f)`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            x^N_i(t) = \text{STFT}^{-1}\tilde{x}_i(f) / F(\tilde{x}_i(f))</span>

<span class="sd">        where :math:`F(\tilde{x}_i(f))` is a characteristic of the spectrogram.</span>

<span class="sd">        **Temporal-domain pre-processing**</span>

<span class="sd">        Considering :math:`x_i(t)` being the seismic trace :math:`x_i(t)`, the</span>
<span class="sd">        normalized trace :math:`\tilde{x}_i(t)` is obtained with</span>

<span class="sd">        .. math::</span>
<span class="sd">            \tilde{x}_i(t) = \frac{x_i(t)}{Fx_i(t) + \epsilon}</span>

<span class="sd">        where :math:`Fx` is a characteristic of the trace :math:`x` that</span>
<span class="sd">        depends on the ``method`` argument, and :math:`\epsilon &gt; 0` is a</span>
<span class="sd">        regularization value to avoid division by 0, set by the ``epsilon``</span>
<span class="sd">        keyword argument.</span>

<span class="sd">        Keyword arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Must be one of &quot;onebit&quot; (default), &quot;mad&quot;, or &quot;smooth&quot;.</span>

<span class="sd">            - &quot;onebit&quot; compress the seismic trace into a series of 0 and 1.</span>
<span class="sd">              In this case, :math:`F` is defined as :math:`Fx(t) = |x(t)|`.</span>

<span class="sd">            - &quot;mad&quot; normalize each trace by its median absolute deviation.</span>
<span class="sd">              In this case, :math:`F` delivers a scalar value defined as</span>
<span class="sd">              :math:`Fx(t) = \text{MAD}x(t) =</span>
<span class="sd">              \text{median}(|x(t) - \langle x(t)\rangle|)`, where</span>
<span class="sd">              :math:`\langle x(t)\rangle)` is the signal&#39;s average.</span>

<span class="sd">            - &quot;smooth&quot; normalize each trace by a smooth version of its</span>
<span class="sd">              envelope. In this case, :math:`F` is obtained from the</span>
<span class="sd">              signal&#39;s Hilbert envelope.</span>

<span class="sd">        smooth_length: int, optional</span>
<span class="sd">            If the ``method`` keyword argument is set to &quot;smooth&quot;, the</span>
<span class="sd">            normalization is performed with the smoothed trace envelopes,</span>
<span class="sd">            calculated over a sliding window of `smooth_length` samples.</span>
<span class="sd">            Note that this parameter is not consider if ``method`` is not</span>
<span class="sd">            set to &quot;smooth&quot;. (`None` by default)</span>

<span class="sd">        smooth_order: int, optional</span>
<span class="sd">            If the ``method`` keyword argument is set to &quot;smooth&quot;, the</span>
<span class="sd">            normalization is performed with the smoothed trace envelopes.</span>
<span class="sd">            The smoothing order is set by the ``smooth_order`` parameter.</span>
<span class="sd">            Note that this parameter is not consider if ``method`` is not</span>
<span class="sd">            set to &quot;smooth&quot;. (`None` by default)</span>

<span class="sd">        epsilon: float, optional</span>
<span class="sd">            Regularization parameter in division, set to ``1e-10`` by default.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="ArrayStream.normalize"><a class="viewcode-back" href="../../api.html#covseisnet.arraystream.ArrayStream.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;onebit&quot;</span><span class="p">,</span>
        <span class="n">smooth_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">smooth_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-10</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalize the seismic traces in temporal domain.</span>

<span class="sd">        Considering :math:`x_i(t)` being the seismic trace :math:`x_i(t)`, the</span>
<span class="sd">        normalized trace :math:`\tilde{x}_i(t)` is obtained with</span>

<span class="sd">        .. math::</span>
<span class="sd">            \tilde{x}_i(t) = \frac{x_i(t)}{Fx_i(t) + \epsilon}</span>

<span class="sd">        where :math:`Fx` is a characteristic of the trace :math:`x` that</span>
<span class="sd">        depends on the ``method`` argument, and :math:`\epsilon &gt; 0` is a</span>
<span class="sd">        regularization value to avoid division by 0, set by the ``epsilon``</span>
<span class="sd">        keyword argument.</span>

<span class="sd">        Keyword arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Must be one of &quot;onebit&quot; (default), &quot;mad&quot;, or &quot;smooth&quot;.</span>

<span class="sd">            - &quot;onebit&quot; compress the seismic trace into a series of 0 and 1.</span>
<span class="sd">              In this case, :math:`F` is defined as :math:`Fx(t) = |x(t)|`.</span>

<span class="sd">            - &quot;mad&quot; normalize each trace by its median absolute deviation.</span>
<span class="sd">              In this case, :math:`F` delivers a scalar value defined as</span>
<span class="sd">              :math:`Fx(t) = \text{MAD}x(t) =</span>
<span class="sd">              \text{median}(|x(t) - \langle x(t)\rangle|)`, where</span>
<span class="sd">              :math:`\langle x(t)\rangle)` is the signal&#39;s average.</span>

<span class="sd">            - &quot;smooth&quot; normalize each trace by a smooth version of its</span>
<span class="sd">              envelope. In this case, :math:`F` is obtained from the</span>
<span class="sd">              signal&#39;s Hilbert envelope.</span>

<span class="sd">        segment_duration_sec : float</span>
<span class="sd">            Duration of the segments for Fourier transformation.</span>

<span class="sd">        Keyword arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        method : str</span>
<span class="sd">            ``&quot;pure&quot;`` or ``&quot;smooth&quot;``. Wheter to consider the division with</span>
<span class="sd">            direct Fourier transform modulus, or a smooth version.</span>

<span class="sd">        smooth : int</span>
<span class="sd">            Smoothing window length in points.</span>

<span class="sd">        smooth_length: int, optional</span>
<span class="sd">            If the ``method`` keyword argument is set to &quot;smooth&quot;, the</span>
<span class="sd">            normalization is performed with the smoothed trace envelopes,</span>
<span class="sd">            calculated over a sliding window of `smooth_length` samples.</span>
<span class="sd">            Note that this parameter is not consider if ``method`` is not</span>
<span class="sd">            set to &quot;smooth&quot;. (`None` by default)</span>

<span class="sd">        smooth_order: int, optional</span>
<span class="sd">            If the ``method`` keyword argument is set to &quot;smooth&quot;, the</span>
<span class="sd">            normalization is performed with the smoothed trace envelopes.</span>
<span class="sd">            The smoothing order is set by the ``smooth_order`` parameter.</span>
<span class="sd">            Note that this parameter is not consider if ``method`` is not</span>
<span class="sd">            set to &quot;smooth&quot;. (`None` by default)</span>

<span class="sd">        epsilon: float, optional</span>
<span class="sd">            Regularization parameter in division, set to ``1e-10`` by default.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;onebit&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;smooth&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">trace_env_smooth</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">smooth_length</span><span class="p">,</span> <span class="n">smooth_order</span>
                <span class="p">)</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="p">(</span><span class="n">trace_env_smooth</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;demad&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">signal</span><span class="o">.</span><span class="n">mad</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span></div>

<div class="viewcode-block" id="ArrayStream.synchronize"><a class="viewcode-back" href="../../api.html#covseisnet.arraystream.ArrayStream.synchronize">[docs]</a>    <span class="k">def</span> <span class="nf">synchronize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="s2">&quot;2010-01-01&quot;</span><span class="p">,</span>
        <span class="n">npts</span><span class="o">=</span><span class="mi">24</span> <span class="o">*</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">20</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Synchronize seismic traces into the same times.</span>

<span class="sd">        So far, this function uses the</span>
<span class="sd">        :meth:`obspy.core.trace.Trace.interpolate` method in order to</span>
<span class="sd">        synchronize the traces. This is not yet optimal (see to-do list).</span>

<span class="sd">        Keyword arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        sampling_rate : float, optional</span>
<span class="sd">            The desired final sampling rate in Hz. Default to 20 Hz.</span>

<span class="sd">        method: str, optional</span>
<span class="sd">            Interpolation method. Default to &quot;linear&quot;.</span>

<span class="sd">        start: str, optional</span>
<span class="sd">            Start date of the interpolation. Default to &quot;2010-01-01&quot;.</span>

<span class="sd">        npts: int, default</span>
<span class="sd">            Number of samples per traces. Default to 1,728,000 samples, the</span>
<span class="sd">            total number of samples on a single day at 20 Hz.</span>


<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        This function is deprecated, and wil be replaced in near future.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span></div>

<div class="viewcode-block" id="ArrayStream.times"><a class="viewcode-back" href="../../api.html#covseisnet.arraystream.ArrayStream.times">[docs]</a>    <span class="k">def</span> <span class="nf">times</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">station_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Common time vector of the ArrayStream.</span>

<span class="sd">        Because the :class:`~covseisnet.data.ArrayStream` is supposed to handle</span>
<span class="sd">        traces with exact same number of samples (and sampling frequency), the</span>
<span class="sd">        time vector of each traces is supposed to be the same. This function</span>
<span class="sd">        only returns the times of one of the traces, accessible from the</span>
<span class="sd">        :meth:`obspy.core.trace.Trace.times` method.</span>

<span class="sd">        Keyword arguments</span>
<span class="sd">        -----------------</span>

<span class="sd">        station_index: int, optional</span>
<span class="sd">            The trace index to extract the time vector from. This has no</span>
<span class="sd">            influence on the returned time vector is the traces have indeed</span>
<span class="sd">            the same sampling, otherwise, you should consider synchronizing</span>
<span class="sd">            the traces first. By default, the first trace is considered.</span>

<span class="sd">        **kwargs: dict, optional</span>
<span class="sd">            Additional keyword arguments are directly passed to the</span>
<span class="sd">            :meth:`obspy.core.trace.Trace.times` (for instance,</span>
<span class="sd">            ``type=&quot;matplotlib&quot;`` allows to recover matplotlib timestamps</span>
<span class="sd">            provided by the :func:`matplotlib.dates.date2num` function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.ndarray` or :class:`list`.</span>
<span class="sd">            An array of timestamps in a :class:`numpy.ndarray` or in a</span>
<span class="sd">            :class:`list`.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        If the times are not synchroneous, the time vector will only correspond</span>
<span class="sd">        to the times of the trace indexed with ``station_index``. The user</span>
<span class="sd">        should ensure that the traces are synchroneous first.</span>

<span class="sd">        Tip</span>
<span class="sd">        ---</span>
<span class="sd">        In order to extract times in matplotlib format, you can set the</span>
<span class="sd">        ``type`` parameter of the</span>
<span class="sd">        :meth:`~obspy.core.trace.Trace.times` method such as</span>

<span class="sd">        &gt;&gt;&gt; import covseisnet as cn</span>
<span class="sd">        &gt;&gt;&gt; st = cn.data.read()</span>
<span class="sd">        &gt;&gt;&gt; st.times(type=&#39;matplotlib&#39;)</span>
<span class="sd">        array([ 733643.01392361,  733643.01392373,  733643.01392384, ...,</span>
<span class="sd">        733643.01427049,  733643.0142706 ,  733643.01427072])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ArrayStream.whiten"><a class="viewcode-back" href="../../api.html#covseisnet.arraystream.ArrayStream.whiten">[docs]</a>    <span class="k">def</span> <span class="nf">whiten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment_duration_sec</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;pure&quot;</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">11</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Spectral normalization of the traces.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_duration_sec : float</span>
<span class="sd">            Duration of the segments for Fourier transformation.</span>

<span class="sd">        Keyword arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        method : str</span>
<span class="sd">            ``&quot;pure&quot;`` or ``&quot;smooth&quot;``. Wheter to consider the division with</span>
<span class="sd">            direct Fourier transform modulus, or a smooth version.</span>

<span class="sd">        smooth : int</span>
<span class="sd">            Smoothing window length in points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pure&quot;</span><span class="p">:</span>
            <span class="n">whiten_method</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">phase</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;smooth&quot;</span><span class="p">:</span>
            <span class="n">whiten_method</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">detrend_spectrum</span>

        <span class="c1"># Initialize for waitbar</span>
        <span class="c1"># waitbar = logtable.waitbar(&#39;Whiten&#39;, len(self))</span>
        <span class="n">fft_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">segment_duration_sec</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Whiten</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">trace</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># waitbar.progress(index)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">data_fft</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">fft_size</span><span class="p">)</span>
            <span class="n">data_fft</span> <span class="o">=</span> <span class="n">whiten_method</span><span class="p">(</span><span class="n">data_fft</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">data_fft</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">fft_size</span><span class="p">)</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># Trim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span>
            <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">starttime</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
            <span class="n">endtime</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="read"><a class="viewcode-back" href="../../api.html#covseisnet.arraystream.read">[docs]</a><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">pathname_or_url</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read seismic waveforms files into an ArrayStream object.</span>

<span class="sd">    This function uses the :func:`obspy.core.stream.read` function to read</span>
<span class="sd">    the streams. A detailed list of arguments and options are available at</span>
<span class="sd">    https://docs.obspy.org. This function opens either one or multiple</span>
<span class="sd">    waveform files given via file name or URL using the ``pathname_or_url``</span>
<span class="sd">    attribute. The format of the waveform file will be automatically detected</span>
<span class="sd">    if not given. See the `Supported Formats` section in</span>
<span class="sd">    the :func:`obspy.core.stream.read` function.</span>

<span class="sd">    This function returns an :class:`~covseisnet.data.ArrayStream` object, an</span>
<span class="sd">    object directly inherited from the :class:`obspy.core.stream.Stream`</span>
<span class="sd">    object.</span>

<span class="sd">    Keyword arguments</span>
<span class="sd">    -----------------</span>
<span class="sd">    pathname_or_url: str or io.BytesIO or None</span>
<span class="sd">        String containing a file name or a URL or a open file-like object.</span>
<span class="sd">        Wildcards are allowed for a file name. If this attribute is omitted,</span>
<span class="sd">        an example :class:`~covseisnet.data.ArrayStream` object will be returned.</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    **kwargs: dict</span>
<span class="sd">        Other parameters are passed to the :func:`obspy.core.stream.read`</span>
<span class="sd">        directly.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~covseisnet.data.ArrayStream`</span>
<span class="sd">        An :class:`~covseisnet.data.ArrayStream` object.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    In most cases a filename is specified as the only argument to</span>
<span class="sd">    :func:`obspy.core.stream.read`. For a quick start you may omit all</span>
<span class="sd">    arguments and ObsPy will create and return a basic example seismogram.</span>
<span class="sd">    Further usages of this function can be seen in the ObsPy documentation.</span>

<span class="sd">    &gt;&gt;&gt; import covseisnet as cn</span>
<span class="sd">    &gt;&gt;&gt; stream = cn.data.read()</span>
<span class="sd">    &gt;&gt;&gt; print(stream)</span>
<span class="sd">    3 Trace(s) in Stream:</span>
<span class="sd">    BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">    BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">    BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z - ... | 100.0 Hz, 3000 samples</span>

<span class="sd">    .. rubric:: _`Further Examples`</span>

<span class="sd">    Example waveform files may be retrieved via https://examples.obspy.org.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">pathname_or_url</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">ArrayStream</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stream</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, The CovSeisNet Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>